//*****************************************************************************************
/*
 * Преобразует ip адрес из строки в ulong(uint32_t) формат
 *
 * !!! Возвращает результат в ulong !!! Имей это ввиду если будешь делать
 *       какие то ~бинарные~ операции ! в особенности сравнение с другим числом(которое
 *       будет signed int). Используй dig2bi для просмотра того что получилось !!!
 *         Как пример (ret | 0x0) != ret ! если было применено sig2unsig и 31-й бит был == 1 !
 */
function my_inet_addr(str_ip){
  var res = 0;
  var octs = str_ip.split('.');
	if(octs.length != 4)
		return 0;
	for(var a = 3; a >= 0; a--){
		var oct = Number(octs[a]);
		if(isNaN(oct))
			oct = 0;
		res <<= 8;
		res |= oct;
	}
  /* так как битовые операции работают со знаковым типом int то
     в результате может получиться переполнение и число станет отрицательным */
  //исправим это
  return sig2unsig(res);
};//---------------------------------------------------------------------------------------

//*****************************************************************************************
/*
 * Преобразует ip адрес из ulong(uint32_t) формата в строку 
 */
function my_inet_ntoa(ip){
  ip = Number(ip);
  var res = "";
  for(var a = 0; a < 4; a++){
    if(a){ res += "." ; }
    res += (ip & 0xFF);
    ip = ip >> 8;
  }
  return res;
};//---------------------------------------------------------------------------------------

//*****************************************************************************************
/* 
 * Преобразует signed int в ulong(uint32_t) формат
 * то есть просто если отрицательное число то прибавляет 0xFFFFFFFF + 1
 * 
 * Но с таким числом уже бинарные операции делать нельзя !!!
 * так как результат получится ~обрезанным~ до 4-х байт ! и ты потеряешь
 * все биты > 31 (останутся только от 0..31) ! 
 */
function sig2unsig(dig){
  /* так как битовые операции работают со знаковым типом int то
     в результате битовой операции может получиться переполнение и
     число станет отрицательным */
  if(dig < 0){
    //исправим это
    dig += 0xFFFFFFFF + 1;
  }
  return dig;
};//---------------------------------------------------------------------------------------

//*****************************************************************************************
/* 
 * Преобразует число в двоичную форму разделяя его точками по 8 разрядов(каждый байт)
 * Удобно для отладки функцию работабщих с бинарной арифметикой.
 */
function dig2bi(dig){
  /* если число отрицательное(больше чем 2147483647)
     нам нужно преобразовать его в 'псевдо' unsigned
     перед конвертированием в строковую бинарную форму */
  var udig = sig2unsig(dig);
  //получаем двоичную строковую форму числа   
  var bis = udig.toString(2);
  var len = bis.length;
  //сколько разрядов не достает до того чтобы быть кратным 8
  var nlen = Math.ceil(len / 8) * 8 - len;
  //дополняем старшие разряды нулями чтобы длина строки была кратна 8
  while(nlen > 0){
    bis = '0' + bis;
    nlen--;
  }
  //теперь длина строки кратна 8. осталось расставить
  //точки через каждые 8 разрядов
  var res = "";
  for(var a = 0; a < bis.length / 8; a++){
    if(res.length > 0){
      res += '.';
    }
    res = res + bis.substr(a * 8, 8);
  }
  //если было применено переконвертирование в unsiged то сообщим про это
  if(dig != udig){
    res = res + '!U';
  }
  return res;
};//---------------------------------------------------------------------------------------

//*****************************************************************************************
/* 
 * Конвертирует маску из числового вида в бинарный(/24 -> 11111111.11111111.11111111.00000000)
 * не забывай что она может быть отрицательной !!! из за signed int-а! Учитывай это !
 * но для битовых операци самое то. им все равно какая она !
 * Главное не забывай где нужноделать что то на подобии & 0xFF
 */
function get_bimask(mask){
  if(mask < 0 || mask > 32){
    mask = 32;
  }
  var res = 0;
  for(var a = 32; a > mask; a--){
    res = res << 1 | 1;
  }
  return res;
};//---------------------------------------------------------------------------------------

//*****************************************************************************************
/* 
 * Преобразует uint32_t из network в byte order
 * 
 * !!! Вернет ~signed~ int !!!
 */
function my_swab32(d){
  d = Number(d);
  //у '>>' приритет больше ! чем у '&' !   
  return (d >> 24 & 0xFF) | ((d >> 16 & 0xFF) << 8) | ((d >> 8 & 0xFF) << 16)  | ((d & 0xFF) << 24);
};//--------------------------------------------------------------------------------------- 

//*****************************************************************************************
/* Определяет порядок байт в целевой системе

	Итак на C мы можем протестировать систему на byte order вот так:
		int d32 = 0xABCDEF;
		unsigned char *d8 = (void*)&d32;
		if(d8[0] == 0xEF)
			printf("little\n");
		else
			printf("big\n");
*/
function get_system_endianes(){
	var d32 = new Uint32Array(1);
	var d8 = new Uint8Array(d32.buffer);
	d32[0] = 0xABCDEF;
	if(d8[0] == 0xEF)
		return "little";
	else
		return "big";
};//--------------------------------------------------------------------------------------- 

//*****************************************************************************************
/*
 * Конвертирует порядок байт из Network(big endian) в порядок байт целевой системы
 */
function my_ntohl(d){
	d = Number(d);
	if(get_system_endianes() == "big")
		return d;
	else
		return my_swab32(d);
};//---------------------------------------------------------------------------------------

//*****************************************************************************************
/*
 * Конвертирует порядок байт из порядка байт целевой системы в Network(big endian)
 */
function my_htonl(d){
	return my_ntohl(d);
};//---------------------------------------------------------------------------------------

//*****************************************************************************************
/*
 * Преобразует число в 16-ти ричную.
 * Удобно для отладки функцию работабщих с бинарной арифметикой.
 */
function dig2hex(dig){
	dig = Number(dig);
	var res = "";
	for(var a = 0; a < 4; a++){
		var o = ((dig >> (a * 8)) & 0xFF).toString(16).toUpperCase();
		if(o.length < 2)
			o = "0" + o;
		res = o + res;
	}
	return "0x" + res;
};//---------------------------------------------------------------------------------------
